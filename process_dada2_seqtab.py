
import csv
import pandas as pd
import argparse

# F_PRIMER = "GTGCCAGCMGCCGCGGTAA"
# R_PRIMER = "GACTACHVGGGTATCTAATCC"
# args.seqtab_path = "./input_seqtab.csv"
# args.barcode_path = "BC_to_well2.csv"
# args.output_path = "processed_data_output.csv"


def main():
    args = get_cli_args()
    global F_PRIMER, R_PRIMER
    F_PRIMER = args.fprimer
    R_PRIMER = args.rprimer
    input_seqtab = read_csv_file(args.seqtab_path)
    input_brcd_well = read_csv_file(args.barcode_path)
    # print(input_seqtab[1:5])
    plate_names = input_seqtab[0][1:len(input_seqtab[0])]
    well_names = get_well_names(input_brcd_well)
    print("--------Plate names----------")
    print(plate_names)
    # print("************")
    # print("--------Well names-----------")
    # print(well_names)
    # print("************")
    plate_well_combo = create_plate_well_combos(plate_names, well_names)
    # print("--------Plate-Well combinations------")
    # print(plate_well_combo)
    # print("************")
    # print(len(plate_well_combo))
    brcd_well_dict = create_well_brcd_lookup(input_brcd_well)
    # print("------Lookup-dictionary-------")
    # print(brcd_well_dict)
    # print("************")
    seq_info_dict = create_seq_plate_dict(input_seqtab)
    # print(seq_info_dict)
    # print("************")
    all_columns = ["original_seq", "f_barcode", "r_barcode", "well", "trimmed_seq"]
    all_columns.extend(plate_well_combo)
    # print(all_columns)
    # Write processed information to a csv file
    get_final_output_csv(all_columns, args.seqtab_path, args.output_path, plate_names, brcd_well_dict)


def get_cli_args():
    arg_parser = argparse.ArgumentParser(description="Identifies well number of each sequence and removes primers and "
                                                     "barcodes from each sequence")
    arg_parser.add_argument("--fprimer", "-fp", type=str, required=True, help="Provide forward primer sequence")
    arg_parser.add_argument("--rprimer", "-rp", type=str, required=True, help="Provide reverse primer sequence")
    arg_parser.add_argument("--seqtab-path", type=str, required=True, 
                            help="Provide path to input seqtab csv file generated by DADA2")
    arg_parser.add_argument("--barcode-path", type=str, required=True,
                            help="Provide path to barcode and well info file")
    arg_parser.add_argument("--output-path", type=str, required=True, help="Provide path output csv file")
    return arg_parser.parse_args()


def read_csv_file(file_path):
    with open(file_path, "r") as csvfile:
        csv_reader = csv.reader(csvfile, delimiter=',')
        all_row = []
        for row in csv_reader:
            all_row.append(row)
        return all_row


def get_well_names(input_brcd_well):
    well_names = []
    for i in range(1, len(input_brcd_well)):
        well_names.append(input_brcd_well[i][2])
    return well_names


def create_plate_well_combos(plate_names, well_names):
    """
    This function concatenates plate name and well name
    (10 plates and 96 wells make 960 plate and well name combos)
    :param plate_names: List of plate names
    :param well_names: List of well names
    :return: List of concatenated plate and well names (length total num
             of plates multiplied by total num of well names)
    """
    plate_well_combo = []
    for i in range(len(plate_names)):
        for j in range(len(well_names)):
            plate_well_combo.append(plate_names[i] + "_" + well_names[j])
    return plate_well_combo


def create_well_brcd_lookup(well_brcd_info):
    """
    This function creates a look-up dictionary
    :param well_brcd_info:
    :return: dictionary where keys are forward barcodes and values are dictionaries with reverse barcode and well num
    """
    brcd_well_dict = {}
    for i in range(1, len(well_brcd_info)):
        if well_brcd_info[i][0] not in brcd_well_dict:
            brcd_well_dict[well_brcd_info[i][0]] = {well_brcd_info[i][1]: well_brcd_info[i][2]}
        else:
            brcd_well_dict[well_brcd_info[i][0]][well_brcd_info[i][1]] = well_brcd_info[i][2]
    return brcd_well_dict


def identify_seq_well(seq, brcd_well_dict):
    f_barcodes = list(brcd_well_dict.keys())
    identified_f_barcode = ""
    identified_r_barcode = ""
    well_num = ""
    for f_barcode in f_barcodes:
        if seq.startswith(f_barcode):
            identified_f_barcode = identified_f_barcode + f_barcode
            r_barcodes = list(brcd_well_dict[identified_f_barcode].keys())
            for r_barcode in r_barcodes:
                if seq.endswith(r_barcode):
                    identified_r_barcode = identified_r_barcode + r_barcode
    if len(identified_f_barcode) > 1 and len(identified_r_barcode) > 1:
        well_num = well_num + brcd_well_dict[identified_f_barcode][identified_r_barcode]
    else:
        well_num = "no_well"
    return identified_f_barcode, identified_r_barcode, well_num


def trim_brcd_and_primer(seq, f_barcode, F_PRIMER, R_PRIMER, r_barcode):
    seq_len = len(seq)
    f_trim = len(f_barcode) + len(F_PRIMER)
    r_trim = len(R_PRIMER) + len(r_barcode)
    trimmed_seq = seq[f_trim:(seq_len - r_trim)]
    return trimmed_seq


def create_seq_plate_dict(input_seqtab):
    seq_info_dict = {}
    for i in range(1, len(input_seqtab)):
        for j in range(0, len(input_seqtab[i])):
            if j == 0:
                plate_dict = dict(
                    zip(input_seqtab[0][1:len(input_seqtab[0])], input_seqtab[i][j + 1:len(input_seqtab[i])]))
                seq_info_dict[input_seqtab[i][j]] = plate_dict
            continue
    return seq_info_dict


def extract_data_from_raw_seq(seqtab_row, plate_names, brcd_well_dict):
    """
    :param seqtab_row: ['AGTCTGGTGCCAGCAGCCGCGGTAAGACGGGGGAGGCAAGTGTTCTTGGAGGAGAAAATTGGATTAGATACCCTAGTAGTCGATCTA', '0', '0', '0', '9', '0', '0', '0', '0', '163', '0']
    :param plate_names: A list of all plate names
    :param brcd_well_dict: A lookup dictionary to identify well number based on barcode combination
    :return:
    """
    raw_seq = seqtab_row[0]
    identified_f_barcode, identified_r_barcode, well_num = identify_seq_well(raw_seq, brcd_well_dict)
    trimmed_seq = trim_brcd_and_primer(raw_seq, identified_f_barcode, F_PRIMER, R_PRIMER, identified_r_barcode)
    seq_details_dict = {}
    seq_details_dict.update({"original_seq": raw_seq,
                             "f_barcode": identified_f_barcode,
                             "r_barcode": identified_r_barcode,
                             "well": well_num,
                             "trimmed_seq": trimmed_seq})

    for i in range(1, len(seqtab_row)):
        plate = str(plate_names[i - 1]) + "_" + well_num
        if int(seqtab_row[i]) > 0:
            seq_details_dict.update({plate: int(seqtab_row[i])})
        else:
            seq_details_dict.update({plate: 0})
    return seq_details_dict


def get_final_output_csv(all_colnames, seqtab_csv, output_csv_filename, plate_names, brcd_well_dict):
    """
    :param all_colnames:
    :param seqtab_csv: egla_seqtab2.csv
    :param output_csv_filename: pandas_full_trial_output.csv
    :return: Final output csv that contains original seq, identified f and r barcodes,
             trimmed seq, all plate_well columns
    """
    input_seqtab = read_csv_file(seqtab_csv)
    all_seq_df = pd.DataFrame(columns=all_colnames)
    for i in range(1, len(input_seqtab)):
        print("Processing sequence " + str(i) + "...")
        extracted_row = extract_data_from_raw_seq(input_seqtab[i], plate_names, brcd_well_dict)
        temporary_df = pd.DataFrame(extracted_row, columns=all_colnames, index=[0])
        # all_seq_df = all_seq_df.append(temporary_df, ignore_index=True)
        pd.concat(all_seq_df, temporary_df, ignore_index=True)
    print(all_seq_df.fillna(0))
    all_seq_df = all_seq_df.fillna(0)
    all_seq_df.to_csv(output_csv_filename, sep=',')


if __name__ == "__main__":
    main()
